# GetAI

## Description

This program is designed to be a user-friendly interface for interacting with an artificial intelligence, acting as a bridge between you and the AI. It's built to handle various instructions and data you might want to send to the AI, and then present the AI's generated responses back to you. To achieve this, the script first gathers all the necessary tools and specialized functions it needs. These include capabilities for managing files, controlling how the program runs, and working with structured information like JSON. It also brings in custom-built helpers from different categories, such as those that manage how functions are used, core operational tasks, file interactions, and specific AI-related actions.

At its heart, the program has two main parts. One is a small helper function that's good at checking if a specific piece of information you provide is among a list of allowed options. It's smart enough to ignore whether you use uppercase or lowercase letters, making it easier for you to input commands. The other, more significant part, is the main engine of the program. This is where all the action happens. It starts by taking whatever instructions or settings you give it when you launch the program. Then, it sets up some default ways to manage the AI's "memory" â€“ deciding whether to start fresh, keep old information, or operate without any memory at all. It looks for special commands you might include to change these memory settings, and if it finds them, it tidies them up so they don't interfere with other tasks.

Before it does anything else, the program makes sure you've given it all the essential details it needs to talk to the AI. This includes specifying which AI system to use, which specific version or "model" of that AI, how much information the AI can handle at once (like a word count limit), a "persona" to guide the AI's personality, and the actual instructions you want the AI to follow. If any of these crucial pieces are missing, the program will let you know and stop. The instructions themselves can be typed directly, or you can point the program to a file that contains them. If it's a file, the program carefully reads its contents, making sure to handle things like separate lines of text and quotation marks correctly.

Finally, the program checks if you've provided any additional data for the AI to work with, perhaps by pasting it directly into the command line. If there's input data, it's processed in a similar way to the instructions. Once all the information is gathered and prepared, the program sets up a specialized AI "agent" with all your chosen settings. This agent is then instructed to generate a response based on your combined instructions and any input data you provided. Once the AI has finished, the program proudly displays the AI's complete response back to you.

## Technical

The provided Python script, `GetAI`, is designed to facilitate interaction with an artificial intelligence (AI) system. It begins by setting up the execution environment and importing necessary modules. The `sys` module is used for system-specific parameters and functions, including manipulating the Python path (`sys.path.append('/home/JackrabbitAI/Library')`) to include a custom library directory. The `os` module provides a way of using operating system dependent functionality, such as accessing environment variables. `select` is a module that can be used to monitor multiple file descriptors for readiness, though its direct use in this snippet is not apparent. `copy` is imported for creating copies of objects, specifically `sys.argv`. `json` is imported for working with JSON data, although it is not directly used in the visible code. The script then imports custom modules: `DecoratorFunctions` aliased as `DF`, `CoreFunctions` as `CF`, `FileFunctions` as `FF`, and `AIFunctions` as `AI`. These modules likely contain helper functions and classes for the script's operation.

The script defines two primary functions: `CheckArgs` and `main`. The `CheckArgs` function, decorated with `@DF.function_trapper(False)`, takes two parameters: `arg` (a string representing an argument to check) and `inlist` (a list of strings to check against). Inside `CheckArgs`, the input `arg` is converted to lowercase using `arg.lower()`. The function then iterates through each `item` in the `inlist`. For each `item`, it also converts it to lowercase using `item.lower()` and compares it with the lowercase `arg`. If a match is found, the function immediately returns `True`. If the loop completes without finding a match, the function returns `False`. The `DF.function_trapper(False)` decorator suggests that this function might have specific error handling or logging behavior configured by the decorator, with `False` potentially indicating a specific mode of operation for the trapper.

The `main` function, decorated with `@DF.function_trapper`, is the core execution logic of the script. It starts by creating a copy of the command-line arguments passed to the script using `sys.argv.copy()`, storing it in the `args` variable. It then initializes several boolean and integer variables to manage AI memory and response size: `ResetMemory` to `False`, `SaveMemory` to `True`, `NoMemory` to `False`, and `maxresp` to `0`. The script proceeds to check for specific command-line flags. It uses the `CheckArgs` function to determine if flags like `'-maxrespsize'`, `'-isolation'`, `'-reset'`, and `'-nomemory'` are present in the `args` list.

If `'-maxrespsize'` is found, its index is retrieved, the flag is removed from `args`, and if there's an element immediately following it in the `args` list, that element is converted to an integer and assigned to `maxresp`, and then removed from `args`. If `'-isolation'` is found, `NoMemory` is set to `True`, and the flag is removed from `args`. Similarly, if `'-reset'` is found, `ResetMemory` is set to `True`, and the flag is removed. If `'-nomemory'` is found, `SaveMemory` is set to `False`, and the flag is removed. These flags control the memory management behavior of the AI agent.

Following the flag processing, the script checks the number of remaining arguments in `args`. If `len(args)` is greater than 5, it proceeds to parse the AI engine, model, maximum tokens, persona, and role. The `engine` is taken from `args[1]`, and if it's `'default'`, it retrieves the value from the environment variable `JRAIengine`. The `model` is taken from `args[2]`, defaulting to `JRAImodel` from the environment if `'default'` is specified. The `mt` (maximum tokens) is taken from `args[3]`, defaulting to the environment variable `JRAItokens` if `'default'`, otherwise it's converted to an integer. The `persona` is taken from `args[4]`, and the `role` (instructions) is taken from `args[5]`. If `len(args)` is not greater than 5, an error message is printed, and the script exits.

The script then handles the `role` parameter. If the `role` string begins with `'@'`, it assumes `role` is a file path. It checks if the file exists using `os.path.exists(role[1:])`. If the file exists, its content is read using `FF.ReadFile(role[1:].strip())`, and newline characters (`\n`) and single quotes (`'`) within the file content are replaced with `\\n` and `''` respectively. If the file does not exist, an error message is printed, and the script exits.

Next, the script checks for input data provided via standard input (STDIN) using `CF.IsSTDIN()`. If STDIN is active, it reads all input using `sys.stdin.read()`, and similar to the `role` processing, newline characters and single quotes are replaced. An `AI.Agent` object is then instantiated with the parsed `engine`, `model`, `maxtokens` (represented by `mt`), `persona`, `reset` (from `ResetMemory`), `save` (from `SaveMemory`), `isolation` (from `NoMemory`), and `maxrespsize` (from `maxresp`). Finally, the `agent.Response()` method is called with a combined string of the `role` and the `input` data, separated by two newline characters. The AI's generated `response` is then printed to the console. The `if __name__ == '__main__':` block ensures that the `main()` function is executed only when the script is run directly.
