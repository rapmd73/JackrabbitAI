# CoreFunctions library

## Descriptions

This script is a collection of helpful tools designed to assist with various tasks, primarily related to processing text and managing system resources. It starts by bringing in a set of pre-built capabilities from the Python language itself, covering things like interacting with the operating system, handling files, working with dates and times, and recognizing patterns in text. It also uses a special helper set of tools called `DecoratorFunctions` to make its own functions work even better.

At the beginning, the script sets up some basic information, like the name of the program itself and a specific location on the computer where it might store temporary data, like "tokens." These pieces of information are like labels that the script uses to keep track of things as it works.

The script then offers several functions for cleaning and preparing text. One function, `DecodeHashCodes`, is like a translator that turns special codes, such as `&#65;`, into their actual characters, like 'A'. Another, `DecodeUnicode`, takes characters that might not be standard and converts them into simpler, more common ones, making the text easier for different systems to understand. There's also a function called `Yesterday` that's meant to figure out what the date was the day before, though it seems to have a small hiccup in how it uses the dates it's given.

For managing how the computer is running, the script has tools to check its workload. `GetLoadAVG` looks at a system file to report how busy the computer is. The `renice` function allows you to tell the computer to give a particular task more or less attention, like telling a worker to focus more or less on their job. `ElasticSleep` and `ElasticDelay` are clever functions that can pause the program's work, but they do it smartly by considering how busy the computer is. If the computer is overloaded, they might pause for a shorter time or adjust how they wait to avoid making things worse.

The script also includes functions for making sure text is in the right format. `NumberOnly` is like a bouncer for numbers, checking if a piece of text looks like a valid number, even if it has some confusing characters or different ways of writing numbers. `StripPunctuation` is a cleaner that removes all the little marks and symbols from text, replacing them with spaces to make the text neat. `jsonFilter` is specifically designed to prepare text so it can be used with a data format called JSON, getting rid of extra spaces or line breaks. Finally, `GetWordList` takes a chunk of text and breaks it down into a list of individual words, all in lowercase and without any empty entries.

## Technical

The provided Python script, identified by the shebang `#!/usr/bin/env python3` and encoding declaration `# -*- coding: utf-8 -*-`, is a collection of utility functions. It begins by importing a comprehensive set of standard Python modules, including `sys` for system-specific parameters and functions, `os` for interacting with the operating system, `io` for input/output operations, `copy` for object copying, `itertools` for efficient looping, `functools` for higher-order functions, `inspect` for introspection, `traceback` for exception handling, `select` for I/O multiplexing, `datetime` for date and time manipulation, `time` for time-related functions, `random` for random number generation, `json` for JSON encoding and decoding, `string` for string constants, and `re` for regular expression operations. Additionally, it imports a custom module named `DecoratorFunctions` as `DF`, indicating the use of decorators to modify or enhance function behavior.

Two global variables are defined: `RunningName` is assigned the name of the currently executing script, obtained from `sys.argv[0]`, and `TokenStorage` is set to the string `'/home/JackrabbitAI/Tokens'`, likely representing a directory path for storing tokens. A global variable `MasterNice` is initialized by calling `os.getpriority(os.PRIO_PROCESS, 0)`, which retrieves the niceness value of the current process (PID 0). This value is intended for measuring and controlling operating system load.

The `DecodeHashCodes` function, decorated with `@DF.function_trapper('')`, takes a single parameter `input_string`. Its purpose is to decode numeric character references within this string, such as `&#65;`. It defines an inner helper function `replace_entity` which accepts a `match` object. Inside `replace_entity`, `match.group(1)` extracts the captured digits (the numeric code) from the regular expression match. This extracted code is then converted to an integer and passed to the `chr()` function to obtain the corresponding character. If a `ValueError` occurs during this conversion (e.g., if the extracted code is not a valid character code), the original matched string (`match.group(0)`) is returned. The main part of `DecodeHashCodes` uses `re.sub` with the regular expression `r'&#(\d+);'` to find all occurrences of numeric character references and applies the `replace_entity` function to each match, returning the string with decoded characters.

The `DecodeUnicode` function, also decorated with `@DF.function_trapper('')`, takes a single parameter `text`. This function aims to replace specific Unicode characters with their ASCII equivalents. It defines a dictionary `replacements` that maps various Unicode characters, including different types of quotation marks, dashes, ellipsis, non-breaking spaces, and others, to their corresponding ASCII representations. The function then iterates through this dictionary, using `text.replace(unicode_char, ascii_char)` for each key-value pair to perform the substitutions. The modified string is returned after all replacements have been made.

The `Yesterday` function, decorated with `@DF.function_trapper('')`, accepts an optional parameter `ds` which defaults to `None`. If `ds` is provided and not `None`, the function attempts to parse it as a date string in the format `'%Y-%m-%d'` using `datetime.datetime.strptime`. However, it incorrectly uses an undefined variable `date_str` instead of the `ds` parameter for parsing. If `ds` is `None`, it uses the current date and time obtained from `datetime.datetime.now()`. In both cases, it calculates yesterday's date by subtracting one day using `datetime.timedelta(days=1)` and returns the result formatted as a string in `'%Y-%m-%d'` format using `yesterday.strftime('%Y-%m-%d')`.

The `GetLoadAVG` function, decorated with `@DF.function_trapper([])`, is designed to retrieve the system's load average. It opens the file `'/proc/loadavg'` in read mode. It then reads the first line of this file using `fh.readline()` and stores it in the variable `l`. After reading, the file handle `fh` is closed. The read line `l` is split into a list of strings using space (' ') as the delimiter, and this list is assigned to the variable `LoadAVG`. Finally, the function returns the `LoadAVG` list, which typically contains values representing the 1-minute, 5-minute, and 15-minute load averages, along with other system information.

The `renice` function, decorated with `@DF.function_trapper`, takes a single integer parameter `n`, representing the desired niceness value. It attempts to set the niceness of the current process (identified by `os.PRIO_PROCESS` and PID `0`) to the value of `n` using `os.setpriority()`. The `try...except: pass` block ensures that if any error occurs during the `os.setpriority` call, it is silently ignored, and the program continues execution without raising an exception.

The `ElasticSleep` function, decorated with `@DF.function_trapper`, takes two parameters: `s` (the base sleep duration) and `Fuzzy` (a boolean flag, defaulting to `True`). If `Fuzzy` is `True`, the function dynamically adjusts the sleep duration based on system load. It calls `GetLoadAVG()` to obtain the load average, `os.cpu_count()` to get the number of CPU cores, and `os.getpriority(os.PRIO_PROCESS, 0)` to get the current process niceness. It calculates a load factor `d` by taking the maximum of the first three load average values, converting it to a float, and dividing by the CPU count. If the load factor `d` is greater than or equal to the CPU count `c`, it increases the process's niceness by 1 using `renice(n+1)`. Otherwise, if the current niceness `n` is greater than `MasterNice`, it decreases the niceness by 1 using `renice(n-1)`. `os.sched_yield()` is called to give up the CPU slice to the kernel. The load factor `d` is then decomposed into integer `i` and fractional `f` parts. A `delay` is calculated as `i + (f / 100)`. A `throttle` value is calculated if `d` exceeds `c`, as `(d - c) * delay`. Finally, `time.sleep()` is called with the sum of `s`, `delay`, and `throttle`. If `Fuzzy` is `False`, the function simply calls `time.sleep(s)` with the provided duration.

The `ElasticDelay` function, decorated with `@DF.function_trapper(0)`, calculates a dynamic delay in milliseconds based on system load. It initializes `throttle` to 0. It calls `GetLoadAVG()` to get the load average values and then determines the maximum of the first three values, converting it to a float and then an integer, storing it in `d`. It also gets the CPU count `c` using `os.cpu_count()`. The load value `d` is decomposed into integer `i` and fractional `f` parts. A `delay` is calculated as `int((i + (f / 100)) * 1000)`, effectively converting the load-based duration into milliseconds. If the load `d` is greater than the CPU count `c`, a `throttle` is calculated as `int((d - c) * delay)`. The function returns the sum of `delay` and `throttle`.

The `NumberOnly` function, decorated with `@DF.function_trapper(None)`, takes a single string parameter `s`. Its purpose is to validate if the input string represents a number, considering various numeric characters and look-alike symbols. It defines a dictionary `look_alike_replacements` to map characters like 'I', 'l', and 'O' to their numeric equivalents '1' and '0'. It then iterates through this dictionary, replacing these look-alike characters in the input string `s`. The string is further processed by stripping leading/trailing whitespace and removing spaces using `s.strip().replace(' ','')`. A set `valid_chars` is initialized with standard digits, comma, and period. It also includes sets for Arabic-Indic digits (`look_alike_chars`) and full-width digits (`full_width_digits`). These sets are combined into `valid_chars`. The function then iterates through each character in the processed string `s`. If any character is not found in `valid_chars`, the function returns `False`. After checking all characters, it performs a basic validation by removing commas and periods from `s` and then checking if the remaining string consists only of digits using `.isdigit()`. If this check passes, it returns `True`; otherwise, it returns `False`.

The `StripPunctuation` function, decorated with `@DF.function_trapper(None)`, takes a single string parameter `text`. It aims to remove punctuation and high ASCII characters (those with ordinal values from 128 to 255) by replacing them with spaces. It defines `punctuation` using `string.punctuation` and creates a string `high_ascii_chars` containing characters from ordinal 128 to 255. It then constructs a translation table using `str.maketrans()`. This table maps each punctuation character and each high ASCII character to a space character. The `text.translate(translation_table)` method is used to apply this mapping to the input `text`, and the resulting `cleaned_text` is returned.

The `jsonFilter` function, decorated with `@DF.function_trapper(None)`, takes a string `s` and an optional boolean parameter `FilterSpace` which defaults to `True`. It first removes newline (`\n`), tab (`\t`), and carriage return (`\r`) characters from `s` and stores the result in `d`. Based on the value of `FilterSpace`, it defines a `filterText` string. If `FilterSpace` is `True`, `filterText` includes tab, carriage return, newline, space, and the non-breaking space character (`\u00A0`). If `FilterSpace` is `False`, it omits the regular space character. The function then iterates through the characters in `filterText` and removes each occurrence from `d` using `d.replace(c, '')`. Finally, it returns the processed string `d`.

The `GetWordList` function, decorated with `@DF.function_trapper(None)`, takes a single string parameter `text`. It converts the input `text` to lowercase using `text.lower()` and then splits it into a list of words using spaces as delimiters with `split()`. It then uses a list comprehension `[word for word in words if word.strip()]` to create a new list containing only those words that are not empty after stripping leading/trailing whitespace. This effectively removes any empty strings that might result from multiple spaces between words. The resulting list of cleaned, lowercase words is returned.

The `IsSTDIN` function, decorated with `@DF.function_trapper(False)`, checks for the availability of input on standard input (STDIN) with a timeout. It utilizes `select.select([sys.stdin], [], [], 1)`. This call monitors `sys.stdin` (the standard input file descriptor) for readability for a maximum of 1 second. The function returns a tuple `(ready, _, _)` where `ready` is a list of file descriptors that are ready for reading. The function then returns this `ready` list. In a boolean context, if `ready` is not empty (meaning input was available within the timeout), the function evaluates to `True`; otherwise, it evaluates to `False`.
