# FileFunctions library

## Description

This code is a collection of helpful tools for managing files and their contents. It's designed to make common tasks like creating folders, reading from files, and writing to files much simpler. Think of it as a digital assistant that handles the nitty-gritty details of file manipulation so you don't have to.

The first set of functions deals with organizing your digital space. There's a tool to create new folders if they don't already exist, which is like making sure you have a clean desk before you start working. Then, there's a function to read the contents of any file, whether it's a plain text document or something more complex. It's smart enough to know if a file is missing and won't cause a fuss if it can't find it.

For adding information to files, there are two handy functions. One lets you add new text to the end of an existing file, like adding a new entry to a diary without erasing what was there before. The other function is for replacing the entire content of a file with new information, like starting a fresh page. These are great for keeping records or updating information.

There's also a function that's a bit more advanced, capable of reading a file and turning its contents into a list of individual lines. You can even tell it to clean up the list by removing blank lines or to make all the text uppercase or lowercase, which is useful for organizing and processing text data.

Finally, there's a specialized tool for handling special configuration files, often used for storing secret codes or settings. This function can find these files, read their information, and even use settings from your computer's environment if you tell it to. It's very careful and will let you know if it can't find the file or if the file is not in the correct format, preventing any unexpected problems.

## Technicals

The provided Python script defines a suite of utility functions for file and directory management, along with a specialized function for reading configuration tokens. The script begins with standard Python imports such as `sys`, `os`, `io`, `copy`, `itertools`, `functools`, `inspect`, `traceback`, `datetime`, `time`, `random`, `json`, `string`, and `re`. It also imports custom modules `DecoratorFunctions` as `DF` and `CoreFunctions` as `CF`, suggesting a structured approach to code organization and potentially the use of decorators for enhanced functionality.

The `mkdir` function is designed to ensure the existence of a directory. It takes a single parameter, `fn`, which represents the path to the directory. Internally, it first checks if the directory specified by `fn` already exists using `os.path.exists(fn)`. If the directory does not exist, it proceeds to create it using `os.makedirs(fn, exist_ok=True)`. The `exist_ok=True` argument is crucial here, as it prevents an error from being raised if the directory already exists, and it also ensures that any necessary parent directories are created along the path. The `@DF.function_trapper(None)` decorator is applied to this function, indicating that it might be wrapped by a decorator from the `DF` module, with `None` potentially being a placeholder or a default argument for the decorator.

The `ReadFile` function is responsible for reading the content of a file. It accepts two parameters: `fn`, the path to the file, and `binary`, a boolean parameter that defaults to `False`. When `binary` is `False` (the default), the file is opened in text mode (`'r'`), its content is read using `cf.read()`, and any leading or trailing whitespace is removed using `.strip()`. If `binary` is `True`, the file is opened in binary read mode (`'rb'`), and its raw byte content is read. In both cases, the file handle `cf` is opened and then closed after reading. The function checks for the existence of the file using `os.path.exists(fn)`. If the file exists, its content is returned; otherwise, `None` is returned. This function is also decorated with `@DF.function_trapper(None)`.

The `AppendFile` function facilitates adding content to the end of a file. It takes two parameters: `fname`, the name of the file to which content will be appended, and `text`, the string content to be added. The function opens the specified file in append mode (`'a+'`), which allows both reading and writing, and importantly, appends new data without overwriting existing content. It then writes the provided `text` to the file using `fh.write(text)` and subsequently closes the file handle `fh`. This function is decorated with `@DF.function_trapper(None)`.

The `WriteFile` function is designed for overwriting a file with new data. It accepts two parameters: `fn`, the filename to which data will be written, and `data`, the content to be written. The function opens the file in write mode (`'w'`), which truncates the file if it exists or creates it if it doesn't. The provided `data` is then written to the file using `cf.write(data)`, and the file handle `cf` is closed. The description notes that this function lacks explicit error handling for file existence, permissions, or data types, implying a direct and potentially less robust writing operation compared to other functions. It is also decorated with `@DF.function_trapper(None)`.

The `ReadFile2List` function reads a file and returns its content as a list of strings, with several optional text manipulation capabilities. Its parameters are `fname` (the file path), `ForceLower` (a boolean defaulting to `False` to convert all lines to lowercase), `ForceUpper` (a boolean defaulting to `False` to convert all lines to uppercase), and `NoStripEmpty` (a boolean defaulting to `False` to control the removal of empty lines). If the file specified by `fname` does not exist, the function returns `None`. It first calls `ReadFile(fname)` to get the file's content, strips leading/trailing whitespace, and splits it into a list of lines using `split('\n')`. If `NoStripEmpty` is `False`, it iteratively removes any empty strings from the `responses` list. If `ForceLower` is `True`, it converts each item in the `responses` list to lowercase using a list comprehension. Similarly, if `ForceUpper` is `True`, it converts each item to uppercase. The function is decorated with `@DF.function_trapper(None)`.

The `ReadTokens` function is specialized for reading and parsing JSON files that contain configuration tokens. It accepts two optional parameters: `gid` and `userhome`. If `gid` is provided (not `None`), the token file is expected to be named after `gid` (e.g., `gid.tokens`). If `gid` is `None`, the function constructs the token filename using the basename of the running program (obtained from `CF.RunningName`) appended with `.tokens`. The `userhome` parameter, if not `None`, overrides the default token storage location specified by `CF.TokenStorage`. The function checks for the existence of the constructed token file (`tfile`). If the file exists, it attempts to read its content using `ReadFile(tfile)` and then parse it as JSON using `json.loads()`. A call to `CF.jsonFilter` is made before parsing, suggesting a pre-processing step for the JSON content. If parsing fails (e.g., due to malformed JSON), an error message is printed, and the program exits with `sys.exit(1)`. If the token file does not exist, a "Missing token file" message is printed, and the program also exits. After successful parsing, the function iterates through the `tokens` dictionary. For any token value that starts with `!environment:` (case-insensitive), it extracts the environment variable name, retrieves its value using `os.getenv()`, and if an environment variable value is found, it updates the token's value with this environment variable's content. The function is decorated with `@DF.function_trapper({})`, where `{}` might represent default or empty arguments for the decorator.
