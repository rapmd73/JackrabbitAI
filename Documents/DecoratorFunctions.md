# DecoratorFunction libraries

## Description

This code is like a toolbox for making other pieces of code (called functions) more helpful and robust. It uses a special technique called "decorators" which are like little add-ons that can be attached to functions to give them extra abilities without changing the original function's core instructions. Think of it like adding a special lens to a camera to get a specific effect, without altering the camera itself.

The code starts by setting up a way to manage where messages normally shown on your screen go. It can redirect these messages, like those from a `print` command, to a file instead. This is super useful for keeping a record of what happened, like a logbook for your program. It has a special manager, `PrintRedirector`, that handles this redirection, making sure messages go to the right place and then returning things to normal when it's done.

Then, it introduces several of these "decorators." One is for sending function output to a log file, which we just talked about. Another decorator is like a stopwatch; it times how long a function takes to run and tells you the result. This is great for figuring out if a part of your program is running too slowly. There's also a decorator that acts like a safety net for errors. If a function runs into a problem, this decorator catches the error, records what went wrong, and then provides a default answer instead of letting the whole program crash. This makes your code much more reliable.

Finally, the code includes a simple example function that divides two numbers. This example function is decorated with all the special abilities we just discussed. When the program runs, it calls this example function twice: once with numbers that divide correctly, and once with numbers that would normally cause an error (like dividing by zero). By doing this, it shows off how the decorators work together to log the output, measure the time it took, and gracefully handle the error, making the whole process smoother and more informative.

## Technical

The provided Python code defines a set of decorators designed to augment the functionality of other Python functions by adding features such as output redirection, execution timing, and error handling. The code begins by importing necessary modules: `sys` for system-specific parameters and functions, `functools` for higher-order functions and operations on callable objects, `inspect` for retrieving information about live objects, `traceback` for extracting, formatting, and printing stack traces, and `time` for time-related functions.

The `PrintRedirector` class is implemented as a context manager. Its `__init__` method takes an optional `file` parameter. If `file` is provided, it's used as the target for output redirection; otherwise, it defaults to the script's name (`sys.argv[0]`) with a `.log` extension. The `original_stdout` attribute stores the current standard output stream. The `__enter__` method opens the specified file in append mode (`'a'`) with UTF-8 encoding, assigns the file object to `self.file_obj`, and then redirects `sys.stdout` to this file object. The `__exit__` method restores `sys.stdout` to its original state (`self.original_stdout`) and closes the file object, ensuring that any output written during the context is properly handled and the system's standard output is reset.

The `function_stdout` function acts as a decorator factory for redirecting function output. It can be invoked in two ways: directly as `@function_stdout` or with a filename as `@function_stdout('logfile.log')`. If called directly, it defaults to using the script's name with a `.log` extension for the log file. If a filename is provided, that filename is used. In both scenarios, it calls the `stdout_helper` function, passing the decorated function and the determined log filename.

The `stdout_helper` function is a decorator factory that creates either a synchronous or asynchronous wrapper function based on whether the input function `func` is a coroutine, as determined by `inspect.iscoroutinefunction(func)`. For asynchronous functions, it defines an `async_wrapper` that uses `await func(*args, **kwargs)` within a `PrintRedirector` context. For synchronous functions, it defines a `sync_wrapper` that calls `func(*args, **kwargs)` within the `PrintRedirector` context. Both wrappers utilize `@functools.wraps(func)` to preserve the original function's metadata, such as its name and docstring.

The `function_timer` decorator is designed to measure and report the execution time of both synchronous and asynchronous functions. It uses `functools.wraps` to preserve metadata. For synchronous functions, it records the time using `time.perf_counter()` before and after executing the function, calculates the `elapsed_time`, prints the function's name and the elapsed time formatted to six decimal places, and then returns the function's result. For asynchronous functions, it employs the same timing mechanism but uses `await func(*args, **kwargs)` to correctly handle asynchronous execution.

The `function_trapper` decorator is responsible for graceful error handling. It accepts an optional `failed_result` parameter, which defaults to `None`. This decorator also differentiates between synchronous and asynchronous functions. For asynchronous functions, it defines an `async_wrapper` that wraps the `await func(*args, **kwargs)` call in a `try...except Exception as err` block. If an exception occurs, it extracts traceback information using `traceback.extract_tb(err.__traceback__)`, identifies the error line number, prints an error message including the function name, line number, and error details, and returns the `failed_result`. For synchronous functions, a `sync_wrapper` performs the same error-catching logic for a direct call to `func(*args, **kwargs)`. The `function_trapper` also handles cases where it's used without parentheses, by checking if `failed_result` is callable and, if so, immediately applying the decorator to it.

The `TestDecorators` function is a simple example function that performs division. It is decorated with `@function_stdout('TestDecorators.log')`, `@function_timer`, and `@function_trapper(0)`. This means that when `TestDecorators` is called, its standard output will be redirected to `TestDecorators.log`, its execution time will be measured and printed, and any exceptions raised during its execution will be caught, logged, and replaced with the value `0`. The `if __name__ == '__main__':` block demonstrates the usage of `TestDecorators` with two sets of arguments: `(5, 3)` for a successful division and `(5, 0)` to trigger a division-by-zero error, showcasing the combined effects of the applied decorators.
